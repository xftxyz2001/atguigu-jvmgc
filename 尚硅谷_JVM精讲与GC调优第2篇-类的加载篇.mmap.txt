第2篇-类的加载篇\n讲师-宋红康
	面试题
	01-类的加载过程（生命周期）
		01-说说类加载分几步？
			都谁需要加载？
			面试题
		02-过程一：Loading(装载)阶段
			1-过程一都做了什么事？
			2-过程一中什么是类模板对象
			3-二进制流有哪些获取方式
			4-Class实例的位置在哪
			5-数组类的加载有什么不同？
		03-过程二：Linking(链接)阶段
			1-环节1：链接阶段之Verification(验证)
			2-环节2：链接阶段之Preparation(准备)
			3-环节3：链接阶段之Resolution(解析)
		04-过程三：Initialization(初始化)阶段
			1-子类加载前先加载父类？
			2-哪些类不会生成<clinit>方法？
			3- 代码举例：static与final的搭配问题
			4-<clinit>()的调用会死锁吗？
			3-类的初始化情况：主动使用vs被动使用
				主动使用的情况
				被动使用的情况
				-XX:+TraceClassLoading
				面试题
			面试代码题1
			面试代码题2
			面试代码题3
			面试代码题4
		05-过程四：类的Using(使用)
		06-过程五：类的Unloading(卸载)
			类、类的加载器、类的实例之间的关系
			何种情况类会被卸载？
			类卸载在实际生产中的情况如何？
			拓展：方法区的垃圾回收
	02-类的加载器
		面试题
		1-作用
		2-类加载的显式加载与隐式加载
		3-类加载机制的必要性
		4-加载的类是唯一的吗？
		5-类加载机制的基本特征
	03-类的加载器分类与测试
		1-类加载器的分类说明
		2-子父类加载器的关系？
		3-具体类的加载器介绍
			引导类加载器
			扩展类加载器
			系统类加载器
		4-用户自定义类加载器
		5-测试不同的类加载器
	04-ClassLoader源码剖析
		面试题
		ClassLoader与现有类加载器的关系
		ClassLoader的主要方法
			loadClass()的剖析
		SecureClassLoader 与 URLClassLoader
		ExtClassLoader 与 AppClassLoader
		Class.forName()与ClassLoader.loadClass()对比
	05-自定义类的加载器
		为什么要自定义类的加载器？
		应用场景有哪些？
		两种实现方式
			对比
			面试题
	06-相关机制
		1-双亲委派机制
			面试题
			定义与本质？
			如何证明？源码分析
			优势与劣势
			破坏双亲委派机制及举例
				面试题
				破坏双亲委派机制1
				破坏双亲委派机制2
				破坏双亲委派机制3
					热替换的实现
			面试题
				源码分析
				5个子问题
		2-沙箱安全机制
			JDK1.0时期
			JDK1.1时期
			JDK1.2时期
			JDK1.6时期
	07-JDK9中类加载结构的新变化
